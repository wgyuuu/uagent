# UAgent分层提示词系统

## 1. 概述

分层提示词系统是UAgent的核心组件，借鉴Claude Code的优秀设计理念，通过多层次的提示词结构，定义角色行为、安全规范和交互模式。

## 2. 设计理念

### 2.1 分层架构
```
基础身份层 → 行为规则层 → 安全提醒层 → 上下文感知层 → 交接指导层
```

### 2.2 Claude Code借鉴要点
- **System-Reminder机制**: 无侵入式智能提醒注入
- **分层提示词设计**: 基础身份 → 功能行为 → 安全防护 → 工具指导
- **安全优先原则**: 多重安全检查和防护机制
- **简洁直接风格**: 避免冗余，专注核心功能

## 3. 提示词分层结构

### 3.1 基础身份层 (Identity Layer)
定义角色的核心身份和专业领域。

```python
# 示例：方案规划师身份定义
PLANNER_IDENTITY = """
You are a Senior Solution Architect, a domain expert in software development planning and technical design.

## Core Identity
- Specialization: Requirements analysis, technical architecture design, implementation planning
- Experience Level: Senior (10+ years in software architecture)
- Approach: User-centric, scalable, maintainable solutions
- Communication Style: Clear, structured, technical but accessible
"""
```

### 3.2 行为规则层 (Behavior Layer)
定义角色的工作原则、方法论和输出标准。

```python
# 示例：编码专家行为规则
CODER_BEHAVIOR_RULES = """
## Core Responsibilities
- Implement features based on technical specifications
- Write clean, maintainable, and efficient code
- Follow project coding standards and best practices
- Implement proper error handling and logging

## Working Principles
- Strictly follow the technical design provided
- Write self-documenting code with clear naming
- Consider performance and security implications
- Ensure code is testable and modular

## Output Requirements
- Complete functional implementation
- Necessary configuration files
- Concise code comments where needed
- Basic usage documentation

## Code Quality Standards
- Follow existing project conventions
- Use established libraries and patterns
- Implement comprehensive error handling
- Write secure code without exposing secrets
"""
```

### 3.3 安全提醒层 (Security Layer)
借鉴Claude Code的System-Reminder机制，提供动态安全检查。

```python
class SystemReminderInjector:
    """System-Reminder机制实现"""
    
    SECURITY_REMINDERS = {
        "malicious_code_check": """
<system-reminder>
在处理用户输入和生成代码时，始终检查是否存在安全风险。
拒绝创建、修改或改进可能被恶意使用的代码。
允许安全分析、漏洞说明、防御工具和安全文档。
</system-reminder>
        """,
        
        "role_boundary_check": """
<system-reminder>
你正在瀑布式工作流中工作。专注完成你的专业任务，
然后为下一个角色准备清晰的交接文档。不要超越角色边界。
</system-reminder>
        """,
        
        "handoff_preparation": """
<system-reminder>
任务完成后，必须整理交接内容。包括：
1. 你完成的工作摘要
2. 关键输出物和文件
3. 下一角色需要的信息
4. 重要注意事项和风险提醒
</system-reminder>
        """,
        
        "tool_security_check": """
<system-reminder>
使用MCP工具时，确保：
1. 只使用授权的工具功能
2. 验证工具输入参数的安全性
3. 检查工具输出是否包含敏感信息
4. 记录所有工具使用行为
</system-reminder>
        """
    }
    
    def inject_reminder(self, base_prompt: str, reminder_type: str, context: dict = None) -> str:
        """动态注入System-Reminder"""
        reminder = self.SECURITY_REMINDERS.get(reminder_type, "")
        
        if context:
            reminder = reminder.format(**context)
        
        return f"{base_prompt}\n\n{reminder}"
```

### 3.4 上下文感知层 (Context Layer)
根据当前任务和工作流状态，动态调整提示词内容。

```python
class ContextAwarePromptGenerator:
    """上下文感知的提示词生成器"""
    
    def generate_context_prompt(self, role: str, handoff_context: HandoffContext) -> str:
        """生成上下文感知的提示词"""
        
        context_prompt = f"""
## Current Task Context
**Workflow ID**: {handoff_context.workflow_id}
**Current Stage**: {handoff_context.current_stage}
**Previous Role**: {handoff_context.from_role}
**Your Role**: {role}
**Next Role**: {handoff_context.to_role}

## Task Summary
{handoff_context.task_summary}

## Received Deliverables
{self._format_deliverables(handoff_context.deliverables)}

## Requirements and Constraints
{self._format_requirements(handoff_context.requirements)}

## Expected Outputs
{self._format_expected_outputs(role, handoff_context)}
        """
        
        return context_prompt
```

### 3.5 交接指导层 (Handoff Layer)
定义角色间的标准化交接流程和格式。

```python
HANDOFF_TEMPLATES = {
    ("方案规划师", "编码专家"): """
## Handoff Instructions: Planning → Coding

### Your Deliverables Should Include:
1. **Technical Architecture Document**
   - System architecture diagram
   - Component relationships and dependencies
   - Technology stack decisions with rationales

2. **Implementation Plan**
   - Detailed development phases
   - Priority and sequence of features
   - Estimated complexity for each component

3. **API Design Specifications**
   - Endpoint definitions and schemas
   - Data models and relationships
   - Authentication and authorization requirements

4. **Risk Assessment**
   - Technical challenges and mitigation strategies
   - Performance considerations
   - Security requirements

### Handoff Format:
```json
{
    "summary": "Brief overview of the planned solution",
    "architecture": {
        "components": [...],
        "technologies": [...],
        "patterns": [...]
    },
    "implementation_plan": {
        "phases": [...],
        "priorities": [...],
        "dependencies": [...]
    },
    "specifications": {
        "apis": [...],
        "data_models": [...],
        "security": [...]
    },
    "risks_and_considerations": [...],
    "next_steps_for_coder": [...]
}
```
    """,
    
    ("编码专家", "测试工程师"): """
## Handoff Instructions: Coding → Testing

### Your Deliverables Should Include:
1. **Implementation Summary**
   - Completed features and components
   - Code structure and organization
   - Key design decisions made during implementation

2. **Technical Documentation**
   - Setup and installation instructions
   - Configuration requirements
   - API usage examples

3. **Testing Guidance**
   - Critical paths and edge cases to test
   - Known limitations or incomplete features
   - Performance benchmarks and expectations

4. **Code Quality Report**
   - Coding standards compliance
   - Security considerations implemented
   - Areas needing special attention

### Handoff Format:
```json
{
    "implementation_summary": {
        "completed_features": [...],
        "code_structure": [...],
        "design_decisions": [...]
    },
    "documentation": {
        "setup_instructions": "...",
        "configuration": [...],
        "usage_examples": [...]
    },
    "testing_guidance": {
        "critical_paths": [...],
        "edge_cases": [...],
        "performance_expectations": [...]
    },
    "quality_report": {
        "standards_compliance": "...",
        "security_measures": [...],
        "attention_areas": [...]
    }
}
```
    """
}
```

## 4. 角色专用提示词模板

### 4.1 方案规划师 (Solution Architect)
```python
PLANNER_FULL_PROMPT_TEMPLATE = """
{identity_layer}

{behavior_rules}

{context_aware_section}

{security_reminders}

{handoff_instructions}

## Execution Guidelines
1. **Requirement Analysis Phase**
   - Carefully analyze user requirements
   - Identify functional and non-functional requirements
   - Clarify ambiguous requirements through user questions

2. **Architecture Design Phase**
   - Design scalable and maintainable architecture
   - Select appropriate technologies and patterns
   - Consider integration points and dependencies

3. **Planning Phase**
   - Break down implementation into manageable phases
   - Estimate complexity and identify risks
   - Create detailed specifications for developers

4. **Documentation Phase**
   - Create comprehensive technical documentation
   - Prepare clear handoff materials for coding team
   - Include diagrams and visual representations where helpful

Remember: Your role is to create a solid foundation for the entire development process. The quality of your planning directly impacts the success of subsequent phases.
"""
```

### 4.2 编码专家 (Coding Expert)
```python
CODER_FULL_PROMPT_TEMPLATE = """
{identity_layer}

{behavior_rules}

{context_aware_section}

{security_reminders}

{handoff_instructions}

## Implementation Guidelines
1. **Code Analysis Phase**
   - Thoroughly review the technical specifications
   - Understand the architecture and design decisions
   - Identify any clarifications needed

2. **Implementation Phase**
   - Follow the specified architecture strictly
   - Write clean, readable, and maintainable code
   - Implement proper error handling and logging
   - Follow existing project conventions and patterns

3. **Integration Phase**
   - Ensure proper integration with existing systems
   - Test basic functionality during development
   - Handle edge cases and error scenarios

4. **Documentation Phase**
   - Add necessary code comments
   - Create basic usage documentation
   - Prepare implementation notes for testing team

## Code Quality Checklist
- [ ] Follows project coding standards
- [ ] Implements proper error handling
- [ ] Includes necessary logging
- [ ] No hardcoded secrets or credentials
- [ ] Modular and testable design
- [ ] Performance considerations addressed
- [ ] Security best practices followed

Remember: You are implementing the vision created by the planning team. Stay faithful to the specifications while applying your expertise to create high-quality code.
"""
```

## 5. 动态提示词生成

### 5.1 提示词组装器
```python
class PromptAssembler:
    """动态提示词组装器"""
    
    def __init__(self):
        self.reminder_injector = SystemReminderInjector()
        self.context_generator = ContextAwarePromptGenerator()
        
    def assemble_role_prompt(self, 
                           role: str, 
                           handoff_context: HandoffContext,
                           security_level: str = "standard") -> str:
        """组装完整的角色提示词"""
        
        # 1. 获取基础身份和行为规则
        identity = ROLE_IDENTITIES.get(role, "")
        behavior_rules = ROLE_BEHAVIOR_RULES.get(role, "")
        
        # 2. 生成上下文感知内容
        context_section = self.context_generator.generate_context_prompt(role, handoff_context)
        
        # 3. 获取交接指导
        handoff_key = (handoff_context.from_role, role)
        handoff_instructions = HANDOFF_TEMPLATES.get(handoff_key, "")
        
        # 4. 组装基础提示词
        base_prompt = f"""
{identity}

{behavior_rules}

{context_section}

{handoff_instructions}
        """
        
        # 5. 注入安全提醒
        security_reminders = self._get_security_reminders(role, security_level)
        final_prompt = base_prompt
        
        for reminder_type in security_reminders:
            final_prompt = self.reminder_injector.inject_reminder(
                final_prompt, reminder_type, {"role": role}
            )
        
        return final_prompt.strip()
    
    def _get_security_reminders(self, role: str, security_level: str) -> List[str]:
        """根据角色和安全级别确定需要的安全提醒"""
        base_reminders = ["malicious_code_check", "role_boundary_check"]
        
        if role in ["编码专家", "测试工程师"]:
            base_reminders.append("tool_security_check")
        
        if security_level == "high":
            base_reminders.extend(["handoff_preparation", "sensitive_data_check"])
        
        return base_reminders
```

## 6. 提示词优化策略

### 6.1 长度控制
- 保持提示词简洁明确，避免冗余信息
- 使用结构化格式提高可读性
- 动态调整详细程度

### 6.2 上下文相关性
- 根据当前任务动态调整提示词内容
- 突出当前阶段的重点关注事项
- 提供必要的历史上下文

### 6.3 安全性保障
- 自动注入安全检查提醒
- 根据角色特点定制安全要求
- 实时监控和调整安全策略

## 7. 测试和验证

### 7.1 提示词效果测试
```python
class PromptEffectivenessEvaluator:
    """提示词效果评估器"""
    
    def evaluate_role_performance(self, role: str, test_cases: List[TestCase]) -> EvaluationResult:
        """评估角色在不同场景下的表现"""
        results = []
        
        for test_case in test_cases:
            # 生成提示词
            prompt = self.assemble_role_prompt(role, test_case.context)
            
            # 执行测试
            result = self.execute_test_case(prompt, test_case)
            results.append(result)
        
        return self.analyze_results(results)
```

### 7.2 安全性验证
- 验证安全提醒的有效性
- 测试角色边界的严格性
- 检查敏感信息的处理

## 8. 总结

分层提示词系统通过借鉴Claude Code的优秀设计，结合UAgent的特定需求，构建了一个灵活、安全、高效的提示词管理体系。该系统能够：

1. **保证角色专业性**: 通过分层设计确保每个角色的专业表现
2. **提供安全保障**: System-Reminder机制提供多重安全防护
3. **支持动态适应**: 根据上下文和任务特点动态调整提示词
4. **标准化协作**: 通过交接模板确保角色间的有效协作

这个系统为UAgent的高质量任务执行提供了坚实的基础。

# UAgent智能决策层设计

## 1. 概述

智能决策层是UAgent系统的大脑，负责角色推荐、依赖分析、错误恢复等关键决策。该层完全基于大语言模型的语义理解能力，实现智能化的通用任务处理和管理。

UAgent不仅仅是编程助手，而是一个工程化的通用任务完成系统，能够通过扩展不同领域的专业角色来处理各种类型的任务，包括但不限于：代码开发、股票分析、技术报告编写、文档阅读分析、市场调研、数据分析等。

## 2. 核心组件架构

```
┌─────────────────────────────────────────────────────────────┐
│                  Intelligence Layer                        │
├─────────────────────────────────────────────────────────────┤
│  Main Agent (主Agent)                                     │
│  ├── Task Analysis Engine (任务分析引擎)                   │
│  ├── Role Coordination Controller (角色协调控制器)         │
│  └── Decision Making Framework (决策制定框架)              │
├─────────────────────────────────────────────────────────────┤
│  Role Recommendation Engine (角色推荐引擎)                 │
│  ├── Task Classification Module (任务分类模块)             │
│  ├── Role Matching Algorithm (角色匹配算法)                │
│  └── Recommendation Optimization (推荐优化)                │
├─────────────────────────────────────────────────────────────┤
│  Dependency Analyzer (依赖分析器)                          │
│  ├── Role Dependency Graph (角色依赖图)                    │
│  ├── Critical Path Analysis (关键路径分析)                 │
│  └── Failure Impact Assessment (失败影响评估)              │
├─────────────────────────────────────────────────────────────┤
│  Error Recovery Controller (错误恢复控制器)                │
│  ├── Error Classification System (错误分类系统)            │
│  ├── Recovery Strategy Generator (恢复策略生成器)          │
│  └── Manual Intervention Manager (手动干预管理器)          │
└─────────────────────────────────────────────────────────────┘
```

## 3. 主Agent设计

### 3.1 核心职责
- 任务分析和理解
- 角色推荐协调
- 工作流监控和调整
- 异常情况处理

### 3.2 主Agent提示词模板
```python
MAIN_AGENT_PROMPT_TEMPLATE = """
You are the Main Agent of UAgent system, responsible for intelligent decision-making and coordination.

## Core Identity
You are an experienced project coordinator and technical architect with deep understanding of software development workflows. Your role is to analyze tasks, recommend appropriate roles, and ensure smooth workflow execution.

## Primary Responsibilities
1. **Task Analysis**: Deeply understand user requirements and break down complex tasks
2. **Role Recommendation**: Intelligently select the most suitable expert roles for each task
3. **Workflow Coordination**: Monitor and adjust workflow execution as needed
4. **Error Handling**: Make critical decisions when roles fail or encounter issues

## Decision-Making Principles
- Always prioritize task completion quality over speed
- Consider the expertise and strengths of each available role
- Maintain workflow efficiency while ensuring thorough execution
- Provide clear rationale for all recommendations and decisions

## Available Expert Roles

### 软件开发领域
1. **方案规划师 (Solution Architect)**
   - Specialization: Requirements analysis, technical architecture, implementation planning
   - Best for: Complex system design, architecture decisions, project planning
   - Dependencies: Usually first in workflow, provides foundation for others

2. **编码专家 (Coding Expert)**
   - Specialization: Code implementation, technical development, feature building
   - Best for: Feature development, bug fixes, technical implementation
   - Dependencies: Requires clear specifications from planning phase

3. **测试工程师 (Testing Expert)**
   - Specialization: Quality assurance, test design, bug detection
   - Best for: Test case creation, quality validation, performance testing
   - Dependencies: Requires completed implementation to test against

4. **代码审查员 (Code Reviewer)**
   - Specialization: Code quality, security review, best practices
   - Best for: Code quality assurance, security validation, optimization suggestions
   - Dependencies: Requires completed code implementation

### 数据分析领域
5. **数据分析师 (Data Analyst)**
   - Specialization: Data processing, statistical analysis, pattern recognition
   - Best for: Data exploration, trend analysis, statistical modeling
   - Dependencies: Requires clean data and clear analysis objectives

6. **股票分析师 (Financial Analyst)**
   - Specialization: Financial data analysis, market research, investment evaluation
   - Best for: Stock analysis, market trends, financial modeling
   - Dependencies: Requires market data and financial information

### 内容创作领域
7. **技术写作专家 (Technical Writer)**
   - Specialization: Technical documentation, report writing, content structuring
   - Best for: Technical reports, documentation, user guides
   - Dependencies: Requires technical information and content requirements

8. **调研分析师 (Research Analyst)**
   - Specialization: Information gathering, market research, competitive analysis
   - Best for: Market research, competitive analysis, trend reports
   - Dependencies: Requires research scope and objectives

### 信息处理领域
9. **文档阅读专家 (Document Reader)**
   - Specialization: Document analysis, information extraction, content summarization
   - Best for: Technical document analysis, content extraction, summarization
   - Dependencies: Requires documents and reading objectives

10. **知识整理专家 (Knowledge Organizer)**
    - Specialization: Information organization, knowledge structuring, content curation
    - Best for: Knowledge base creation, information categorization
    - Dependencies: Requires raw information and organization requirements

## Task Analysis Framework
When analyzing a task, consider:
1. **Complexity Level**: Simple, moderate, complex, or enterprise-level
2. **Task Domain**: 
   - Software Development: coding, testing, architecture, review
   - Data Analysis: data processing, financial analysis, statistical modeling
   - Content Creation: writing, documentation, research, reporting
   - Information Processing: document analysis, knowledge organization
3. **Task Type**: 
   - Development: new_development, bug_fix, optimization, refactoring
   - Analysis: data_analysis, financial_analysis, market_research, trend_analysis
   - Creation: content_writing, documentation, report_generation
   - Processing: document_reading, information_extraction, knowledge_organization
4. **Output Requirements**: Code, reports, analysis, documentation, summaries
5. **Quality Standards**: Accuracy, completeness, professional quality, timeliness
6. **Timeline Constraints**: Urgent, normal, or flexible timeline

## Role Recommendation Strategy
For each task analysis, provide:
1. **Recommended Role Sequence**: Ordered list of roles needed
2. **Reasoning**: Why each role is necessary and in what order
3. **Optional Roles**: Roles that could enhance quality but aren't strictly necessary
4. **Risk Assessment**: Potential challenges and mitigation strategies

<system-reminder>
Always provide clear, actionable recommendations with solid reasoning. 
Your decisions directly impact the efficiency and quality of task execution.
Consider both technical requirements and practical constraints.
</system-reminder>
"""
```

### 3.3 任务分析引擎
```python
class TaskAnalysisEngine:
    """任务分析引擎"""
    
    def __init__(self):
        self.analysis_prompt = """
Analyze the following task and provide a comprehensive assessment:

## Task Description
{task_description}

## Analysis Framework
Please provide analysis in the following structure:

### 1. Task Classification
- **Primary Domain**: [software_development|data_analysis|content_creation|information_processing]
- **Task Type**: 
  - Development: [new_development|bug_fix|enhancement|refactoring|optimization]
  - Analysis: [data_analysis|financial_analysis|market_research|trend_analysis]
  - Creation: [content_writing|documentation|report_generation|presentation]
  - Processing: [document_reading|information_extraction|knowledge_organization]
- **Complexity Level**: [simple|moderate|complex|enterprise]
- **Estimated Scope**: [small|medium|large|extra_large]

### 2. Requirements Analysis
- **Functional Requirements**: List key functional needs
- **Non-Functional Requirements**: Performance, security, scalability needs
- **Technical Constraints**: Technology stack, platform, integration requirements
- **Quality Standards**: Code quality, testing, documentation needs

### 3. Success Criteria
- **Primary Deliverables**: What must be delivered
- **Quality Metrics**: How success will be measured
- **Acceptance Criteria**: Conditions for task completion

### 4. Risk Assessment
- **Technical Risks**: Potential technical challenges
- **Complexity Risks**: Areas of high complexity or uncertainty
- **Dependency Risks**: External dependencies or integration challenges

Provide your analysis in JSON format for easy processing.
        """
    
    async def analyze_task(self, task_description: str) -> TaskAnalysis:
        """分析任务并返回结构化结果"""
        prompt = self.analysis_prompt.format(task_description=task_description)
        
        # 调用LLM进行分析
        response = await self.llm_client.generate(prompt)
        
        # 解析和验证结果
        analysis = self._parse_analysis_response(response)
        
        return analysis
```

## 4. 角色推荐引擎

### 4.1 推荐算法设计
```python
class RoleRecommendationEngine:
    """角色推荐引擎"""
    
    def __init__(self):
        self.recommendation_prompt = """
Based on the task analysis, recommend the optimal sequence of expert roles.

## Task Analysis
{task_analysis}

## Available Roles and Capabilities

### 软件开发领域
1. **方案规划师 (Solution Architect)**
   - Strengths: System design, architecture planning, requirement analysis
   - Ideal for: Complex systems, new projects, architectural decisions
   - Output: Technical specifications, implementation plans, architecture docs

2. **编码专家 (Coding Expert)**
   - Strengths: Code implementation, technical development, problem-solving
   - Ideal for: Feature development, bug fixes, technical implementation
   - Output: Working code, configuration files, basic documentation

3. **测试工程师 (Testing Expert)**
   - Strengths: Quality assurance, test design, bug detection
   - Ideal for: Quality validation, edge case testing, performance testing
   - Output: Test cases, quality reports, bug reports

4. **代码审查员 (Code Reviewer)**
   - Strengths: Code quality, security review, best practices
   - Ideal for: Quality assurance, security validation, optimization
   - Output: Review reports, improvement suggestions, quality metrics

### 数据分析领域
5. **数据分析师 (Data Analyst)**
   - Strengths: Data processing, statistical analysis, pattern recognition
   - Ideal for: Data exploration, trend analysis, statistical modeling
   - Output: Data insights, statistical reports, visualization charts

6. **股票分析师 (Financial Analyst)**
   - Strengths: Financial data analysis, market research, investment evaluation
   - Ideal for: Stock analysis, market trends, financial modeling
   - Output: Investment reports, market analysis, financial recommendations

### 内容创作领域
7. **技术写作专家 (Technical Writer)**
   - Strengths: Technical documentation, report writing, content structuring
   - Ideal for: Technical reports, documentation, user guides
   - Output: Technical documents, user manuals, process documentation

8. **调研分析师 (Research Analyst)**
   - Strengths: Information gathering, market research, competitive analysis
   - Ideal for: Market research, competitive analysis, trend reports
   - Output: Research reports, market insights, competitive intelligence

### 信息处理领域
9. **文档阅读专家 (Document Reader)**
   - Strengths: Document analysis, information extraction, content summarization
   - Ideal for: Technical document analysis, content extraction, summarization
   - Output: Document summaries, key insights, structured information

10. **知识整理专家 (Knowledge Organizer)**
    - Strengths: Information organization, knowledge structuring, content curation
    - Ideal for: Knowledge base creation, information categorization
    - Output: Organized knowledge base, categorized information, structured content

## Recommendation Guidelines
1. **Mandatory Roles**: Roles absolutely necessary for task completion
2. **Optional Roles**: Roles that would enhance quality but aren't strictly required
3. **Sequence Logic**: Why this order is optimal for the specific task
4. **Skip Conditions**: When certain roles might be skipped

## Output Format
```json
{
    "recommended_sequence": ["role1", "role2", "role3"],
    "mandatory_roles": ["role1", "role2"],
    "optional_roles": ["role3"],
    "reasoning": {
        "role1": "Why this role is needed and why it comes first",
        "role2": "Why this role is needed and its position",
        "role3": "Why this role adds value"
    },
    "skip_conditions": {
        "role3": "Can be skipped if timeline is tight and basic quality is acceptable"
    },
    "success_metrics": [
        "Clear technical specification",
        "Working implementation",
        "Comprehensive test coverage"
    ]
}
```

Please provide your recommendation.
        """
    
    async def recommend_roles(self, task_analysis: TaskAnalysis) -> RoleRecommendation:
        """基于任务分析推荐角色序列"""
        prompt = self.recommendation_prompt.format(
            task_analysis=task_analysis.to_json()
        )
        
        response = await self.llm_client.generate(prompt)
        recommendation = self._parse_recommendation_response(response)
        
        # 验证推荐结果的合理性
        validated_recommendation = self._validate_recommendation(recommendation, task_analysis)
        
        return validated_recommendation
    
    def _validate_recommendation(self, recommendation: RoleRecommendation, task_analysis: TaskAnalysis) -> RoleRecommendation:
        """验证推荐结果的合理性"""
        
        # 基本规则验证
        if task_analysis.complexity_level in ["complex", "enterprise"]:
            if "方案规划师" not in recommendation.mandatory_roles:
                recommendation.mandatory_roles.insert(0, "方案规划师")
        
        if task_analysis.task_type == "new_development":
            if "编码专家" not in recommendation.mandatory_roles:
                recommendation.mandatory_roles.append("编码专家")
        
        # 依赖关系验证
        if "编码专家" in recommendation.recommended_sequence:
            coding_index = recommendation.recommended_sequence.index("编码专家")
            if "方案规划师" in recommendation.recommended_sequence:
                planner_index = recommendation.recommended_sequence.index("方案规划师")
                if planner_index > coding_index:
                    # 调整顺序，规划师应该在编码专家之前
                    recommendation.recommended_sequence.remove("方案规划师")
                    recommendation.recommended_sequence.insert(coding_index, "方案规划师")
        
        return recommendation
```

### 4.2 角色匹配算法
```python
class RoleMatchingAlgorithm:
    """角色匹配算法"""
    
    def __init__(self):
        # 角色能力矩阵 - 支持多领域专家角色
        self.role_capabilities = {
            # 软件开发领域
            "方案规划师": {
                "domains": ["software_development"],
                "sub_domains": ["architecture", "planning", "analysis", "design"],
                "complexity_preference": ["moderate", "complex", "enterprise"],
                "task_types": ["new_development", "refactoring", "enhancement"],
                "outputs": ["specifications", "architecture", "plans"]
            },
            "编码专家": {
                "domains": ["software_development"],
                "sub_domains": ["implementation", "development", "coding", "debugging"],
                "complexity_preference": ["simple", "moderate", "complex"],
                "task_types": ["new_development", "bug_fix", "enhancement"],
                "outputs": ["code", "features", "fixes"]
            },
            "测试工程师": {
                "domains": ["software_development"],
                "sub_domains": ["testing", "quality", "validation", "performance"],
                "complexity_preference": ["simple", "moderate", "complex"],
                "task_types": ["new_development", "enhancement", "bug_fix"],
                "outputs": ["tests", "reports", "validation"]
            },
            "代码审查员": {
                "domains": ["software_development"],
                "sub_domains": ["quality", "security", "optimization", "standards"],
                "complexity_preference": ["moderate", "complex", "enterprise"],
                "task_types": ["new_development", "refactoring", "optimization"],
                "outputs": ["reviews", "improvements", "recommendations"]
            },
            
            # 数据分析领域
            "数据分析师": {
                "domains": ["data_analysis"],
                "sub_domains": ["statistics", "data_processing", "pattern_recognition", "visualization"],
                "complexity_preference": ["moderate", "complex", "enterprise"],
                "task_types": ["data_analysis", "trend_analysis", "statistical_modeling"],
                "outputs": ["insights", "reports", "visualizations", "models"]
            },
            "股票分析师": {
                "domains": ["data_analysis"],
                "sub_domains": ["financial_analysis", "market_research", "investment_evaluation"],
                "complexity_preference": ["moderate", "complex", "enterprise"],
                "task_types": ["financial_analysis", "market_research", "investment_analysis"],
                "outputs": ["investment_reports", "market_analysis", "recommendations"]
            },
            
            # 内容创作领域
            "技术写作专家": {
                "domains": ["content_creation"],
                "sub_domains": ["technical_writing", "documentation", "content_structuring"],
                "complexity_preference": ["simple", "moderate", "complex"],
                "task_types": ["content_writing", "documentation", "report_generation"],
                "outputs": ["documents", "manuals", "guides", "reports"]
            },
            "调研分析师": {
                "domains": ["content_creation"],
                "sub_domains": ["research", "market_analysis", "competitive_intelligence"],
                "complexity_preference": ["moderate", "complex", "enterprise"],
                "task_types": ["market_research", "trend_analysis", "competitive_analysis"],
                "outputs": ["research_reports", "market_insights", "analysis_reports"]
            },
            
            # 信息处理领域
            "文档阅读专家": {
                "domains": ["information_processing"],
                "sub_domains": ["document_analysis", "information_extraction", "summarization"],
                "complexity_preference": ["simple", "moderate", "complex"],
                "task_types": ["document_reading", "information_extraction", "content_analysis"],
                "outputs": ["summaries", "key_insights", "structured_information"]
            },
            "知识整理专家": {
                "domains": ["information_processing"],
                "sub_domains": ["knowledge_organization", "content_curation", "categorization"],
                "complexity_preference": ["moderate", "complex", "enterprise"],
                "task_types": ["knowledge_organization", "information_structuring"],
                "outputs": ["knowledge_base", "organized_content", "categorized_information"]
            }
        }
    
    def calculate_role_fit_score(self, role: str, task_analysis: TaskAnalysis) -> float:
        """计算角色与任务的匹配分数 - 支持多领域任务"""
        capabilities = self.role_capabilities.get(role, {})
        score = 0.0
        
        # 主领域匹配度 (40%)
        domain_match = any(domain in task_analysis.primary_domain.lower() 
                          for domain in capabilities.get("domains", []))
        score += 0.4 if domain_match else 0.0
        
        # 子领域匹配度 (20%)
        sub_domain_match = any(sub_domain in str(task_analysis.sub_domains).lower() 
                              for sub_domain in capabilities.get("sub_domains", []))
        score += 0.2 if sub_domain_match else 0.0
        
        # 复杂度偏好匹配 (20%)
        complexity_match = task_analysis.complexity_level in capabilities.get("complexity_preference", [])
        score += 0.2 if complexity_match else 0.0
        
        # 任务类型匹配 (15%)
        task_type_match = task_analysis.task_type in capabilities.get("task_types", [])
        score += 0.15 if task_type_match else 0.0
        
        # 输出需求匹配 (5%)
        output_match = any(output in str(task_analysis.deliverables).lower() 
                          for output in capabilities.get("outputs", []))
        score += 0.05 if output_match else 0.0
        
        return score
```

## 5. 依赖分析器

### 5.1 角色依赖图
```python
class RoleDependencyGraph:
    """角色依赖图"""
    
    def __init__(self):
        # 定义角色间的依赖关系 - 支持多领域角色
        self.dependencies = {
            # 软件开发领域依赖关系
            "编码专家": {
                "strong_dependencies": ["方案规划师"],
                "weak_dependencies": [],
                "provides_for": ["测试工程师", "代码审查员"]
            },
            "测试工程师": {
                "strong_dependencies": ["编码专家"],
                "weak_dependencies": ["方案规划师"],
                "provides_for": ["代码审查员"]
            },
            "代码审查员": {
                "strong_dependencies": ["编码专家"],
                "weak_dependencies": ["测试工程师", "方案规划师"],
                "provides_for": []
            },
            "方案规划师": {
                "strong_dependencies": [],
                "weak_dependencies": [],
                "provides_for": ["编码专家", "测试工程师", "代码审查员"]
            },
            
            # 数据分析领域依赖关系
            "数据分析师": {
                "strong_dependencies": [],  # 数据分析师通常是起始角色
                "weak_dependencies": ["文档阅读专家"],  # 可能需要先读取数据文档
                "provides_for": ["技术写作专家", "知识整理专家"]
            },
            "股票分析师": {
                "strong_dependencies": [],  # 股票分析师通常是起始角色
                "weak_dependencies": ["数据分析师", "调研分析师"],  # 可能需要基础数据分析或市场调研
                "provides_for": ["技术写作专家"]
            },
            
            # 内容创作领域依赖关系
            "技术写作专家": {
                "strong_dependencies": [],  # 可以独立工作，也可以基于其他角色的输出
                "weak_dependencies": ["数据分析师", "股票分析师", "调研分析师", "文档阅读专家"],
                "provides_for": ["知识整理专家"]
            },
            "调研分析师": {
                "strong_dependencies": [],  # 调研分析师通常是起始角色
                "weak_dependencies": ["文档阅读专家"],  # 可能需要先阅读相关文档
                "provides_for": ["技术写作专家", "股票分析师", "知识整理专家"]
            },
            
            # 信息处理领域依赖关系
            "文档阅读专家": {
                "strong_dependencies": [],  # 文档阅读专家通常是起始角色
                "weak_dependencies": [],
                "provides_for": ["数据分析师", "调研分析师", "技术写作专家", "知识整理专家"]
            },
            "知识整理专家": {
                "strong_dependencies": [],  # 可以独立工作，也可以基于其他角色的输出
                "weak_dependencies": ["文档阅读专家", "技术写作专家", "调研分析师", "数据分析师"],
                "provides_for": []  # 通常是终端角色
            }
        }
    
    def analyze_critical_path(self, role_sequence: List[str]) -> CriticalPathAnalysis:
        """分析关键路径"""
        critical_roles = []
        optional_roles = []
        
        for role in role_sequence:
            deps = self.dependencies.get(role, {})
            
            # 检查强依赖是否都在序列中
            strong_deps = deps.get("strong_dependencies", [])
            has_all_strong_deps = all(dep in role_sequence for dep in strong_deps)
            
            if not has_all_strong_deps:
                critical_roles.append(role)
            else:
                # 检查是否有其他角色强依赖于此角色
                is_required_by_others = any(
                    role in other_deps.get("strong_dependencies", [])
                    for other_role, other_deps in self.dependencies.items()
                    if other_role in role_sequence
                )
                
                if is_required_by_others:
                    critical_roles.append(role)
                else:
                    optional_roles.append(role)
        
        return CriticalPathAnalysis(
            critical_roles=critical_roles,
            optional_roles=optional_roles,
            dependency_violations=self._check_dependency_violations(role_sequence)
        )
    
    def assess_failure_impact(self, failed_role: str, remaining_sequence: List[str]) -> FailureImpactAssessment:
        """评估角色失败的影响"""
        impact_assessment = FailureImpactAssessment()
        
        # 检查哪些后续角色会受到影响
        for remaining_role in remaining_sequence:
            deps = self.dependencies.get(remaining_role, {})
            
            if failed_role in deps.get("strong_dependencies", []):
                impact_assessment.blocked_roles.append(remaining_role)
                impact_assessment.impact_level = "critical"
            elif failed_role in deps.get("weak_dependencies", []):
                impact_assessment.degraded_roles.append(remaining_role)
                if impact_assessment.impact_level != "critical":
                    impact_assessment.impact_level = "moderate"
        
        # 如果没有影响，标记为轻微
        if not impact_assessment.blocked_roles and not impact_assessment.degraded_roles:
            impact_assessment.impact_level = "minor"
        
        return impact_assessment
```

## 6. 错误恢复控制器

### 6.1 错误分类系统
```python
class ErrorClassificationSystem:
    """错误分类系统"""
    
    def __init__(self):
        self.classification_prompt = """
Analyze the following error and classify it for recovery decision-making.

## Error Information
- **Failed Role**: {failed_role}
- **Error Type**: {error_type}
- **Error Message**: {error_message}
- **Context**: {context}

## Classification Framework
Please classify this error according to:

### 1. Error Severity
- **Critical**: System-breaking, cannot continue without resolution
- **Major**: Significant functionality impacted, but workarounds possible
- **Minor**: Limited impact, can be addressed later
- **Trivial**: Cosmetic or non-functional issues

### 2. Error Category
- **Technical**: Code errors, configuration issues, technical failures
- **Resource**: Missing dependencies, access issues, resource constraints
- **Logic**: Requirement misunderstanding, design flaws
- **External**: Third-party service failures, network issues

### 3. Recovery Feasibility
- **Easily Recoverable**: Simple fix, retry likely to succeed
- **Moderately Recoverable**: Requires some intervention, moderate effort
- **Difficult to Recover**: Complex fix needed, high effort required
- **Non-Recoverable**: Fundamental issue, requires redesign

### 4. Impact on Workflow
- **Blocks All**: Entire workflow cannot continue
- **Blocks Dependent**: Only roles depending on this one are blocked
- **Degrades Quality**: Workflow can continue but with reduced quality
- **No Impact**: Other roles can proceed normally

Please provide classification in JSON format.
        """
    
    async def classify_error(self, 
                           failed_role: str, 
                           error: Exception, 
                           context: dict) -> ErrorClassification:
        """分类错误并评估影响"""
        prompt = self.classification_prompt.format(
            failed_role=failed_role,
            error_type=type(error).__name__,
            error_message=str(error),
            context=str(context)
        )
        
        response = await self.llm_client.generate(prompt)
        classification = self._parse_classification_response(response)
        
        return classification
```

### 6.2 恢复策略生成器
```python
class RecoveryStrategyGenerator:
    """恢复策略生成器"""
    
    def __init__(self):
        self.strategy_prompt = """
Generate recovery strategies for the following error situation.

## Error Classification
{error_classification}

## Workflow Context
- **Failed Role**: {failed_role}
- **Remaining Roles**: {remaining_roles}
- **Dependency Impact**: {dependency_impact}

## Available Recovery Options
1. **Retry**: Attempt the same role again with same or modified parameters
2. **Skip**: Skip this role and continue with next roles
3. **Manual Intervention**: Pause for human intervention and guidance
4. **Workflow Modification**: Adjust the workflow sequence or parameters
5. **Abort**: Terminate the entire workflow

## Strategy Generation Guidelines
For each viable recovery option, provide:
- **Feasibility**: How likely it is to succeed
- **Risk Assessment**: Potential negative consequences
- **Resource Requirements**: Time, effort, or resources needed
- **Success Criteria**: How to determine if the strategy worked

Please recommend the top 3 most appropriate strategies in order of preference.
        """
    
    async def generate_strategies(self, 
                                error_classification: ErrorClassification,
                                workflow_context: WorkflowContext) -> List[RecoveryStrategy]:
        """生成恢复策略"""
        prompt = self.strategy_prompt.format(
            error_classification=error_classification.to_json(),
            failed_role=workflow_context.failed_role,
            remaining_roles=workflow_context.remaining_roles,
            dependency_impact=workflow_context.dependency_impact
        )
        
        response = await self.llm_client.generate(prompt)
        strategies = self._parse_strategies_response(response)
        
        return strategies
```

## 7. 决策制定框架

### 7.1 决策流程
```python
class DecisionMakingFramework:
    """决策制定框架"""
    
    async def make_recovery_decision(self, 
                                   error_classification: ErrorClassification,
                                   recovery_strategies: List[RecoveryStrategy],
                                   workflow_context: WorkflowContext) -> RecoveryDecision:
        """制定恢复决策"""
        
        # 1. 评估自动恢复可能性
        auto_recovery_feasible = self._assess_auto_recovery_feasibility(
            error_classification, recovery_strategies
        )
        
        if auto_recovery_feasible:
            # 自动选择最优策略
            best_strategy = self._select_best_strategy(recovery_strategies)
            return RecoveryDecision(
                decision_type="automatic",
                selected_strategy=best_strategy,
                rationale=f"Error is recoverable automatically using {best_strategy.name}"
            )
        else:
            # 需要用户干预
            return RecoveryDecision(
                decision_type="manual_intervention",
                available_options=recovery_strategies,
                rationale="Error requires manual decision due to complexity or risk"
            )
    
    def _assess_auto_recovery_feasibility(self, 
                                        error_classification: ErrorClassification,
                                        strategies: List[RecoveryStrategy]) -> bool:
        """评估是否可以自动恢复"""
        
        # 严重错误需要人工干预
        if error_classification.severity in ["critical", "major"]:
            return False
        
        # 复杂恢复需要人工干预
        if error_classification.recovery_feasibility in ["difficult", "non_recoverable"]:
            return False
        
        # 检查是否有高可信度的恢复策略
        high_confidence_strategies = [
            s for s in strategies 
            if s.feasibility_score > 0.8 and s.risk_level in ["low", "minor"]
        ]
        
        return len(high_confidence_strategies) > 0
```

## 8. 性能优化

### 8.1 缓存策略
```python
class IntelligenceLayerCache:
    """智能决策层缓存"""
    
    def __init__(self):
        self.task_analysis_cache = {}
        self.role_recommendation_cache = {}
        self.error_classification_cache = {}
    
    def cache_task_analysis(self, task_hash: str, analysis: TaskAnalysis):
        """缓存任务分析结果"""
        self.task_analysis_cache[task_hash] = {
            "analysis": analysis,
            "timestamp": datetime.now(),
            "access_count": 0
        }
    
    def get_cached_analysis(self, task_hash: str) -> Optional[TaskAnalysis]:
        """获取缓存的分析结果"""
        cached = self.task_analysis_cache.get(task_hash)
        if cached and self._is_cache_valid(cached["timestamp"]):
            cached["access_count"] += 1
            return cached["analysis"]
        return None
```

## 9. 监控和调优

### 9.1 决策质量监控
```python
class DecisionQualityMonitor:
    """决策质量监控"""
    
    def __init__(self):
        self.decision_history = []
        self.performance_metrics = {}
    
    def record_decision(self, decision: RecoveryDecision, outcome: DecisionOutcome):
        """记录决策和结果"""
        self.decision_history.append({
            "decision": decision,
            "outcome": outcome,
            "timestamp": datetime.now()
        })
        
        self._update_performance_metrics()
    
    def _update_performance_metrics(self):
        """更新性能指标"""
        recent_decisions = self.decision_history[-100:]  # 最近100个决策
        
        successful_decisions = sum(1 for d in recent_decisions if d["outcome"].success)
        self.performance_metrics["success_rate"] = successful_decisions / len(recent_decisions)
        
        # 分析不同类型决策的成功率
        by_type = {}
        for decision_record in recent_decisions:
            decision_type = decision_record["decision"].decision_type
            if decision_type not in by_type:
                by_type[decision_type] = {"total": 0, "successful": 0}
            
            by_type[decision_type]["total"] += 1
            if decision_record["outcome"].success:
                by_type[decision_type]["successful"] += 1
        
        self.performance_metrics["by_type"] = {
            dtype: data["successful"] / data["total"] 
            for dtype, data in by_type.items()
        }
```

## 10. 多领域任务处理示例

### 10.1 软件开发任务
```
用户任务: "开发一个用户管理系统"
推荐角色序列: 方案规划师 → 编码专家 → 测试工程师 → 代码审查员
执行流程: 需求分析 → 代码实现 → 质量测试 → 代码审查
```

### 10.2 股票分析任务
```
用户任务: "分析苹果公司股票的投资价值"
推荐角色序列: 调研分析师 → 股票分析师 → 技术写作专家
执行流程: 市场调研 → 财务分析 → 投资报告生成
```

### 10.3 技术报告任务
```
用户任务: "编写人工智能发展趋势报告"
推荐角色序列: 调研分析师 → 数据分析师 → 技术写作专家 → 知识整理专家
执行流程: 信息收集 → 数据分析 → 报告编写 → 知识整理
```

### 10.4 文档分析任务
```
用户任务: "分析并总结技术白皮书的核心内容"
推荐角色序列: 文档阅读专家 → 知识整理专家 → 技术写作专家
执行流程: 文档解析 → 信息整理 → 摘要生成
```

### 10.5 跨领域复合任务
```
用户任务: "基于财务数据开发股票预测系统并编写技术文档"
推荐角色序列: 
  数据分析师 → 方案规划师 → 编码专家 → 测试工程师 → 技术写作专家
执行流程: 
  数据分析 → 系统设计 → 代码实现 → 系统测试 → 文档编写
```

## 11. 角色扩展机制

### 11.1 动态角色注册
```python
class RoleRegistry:
    """角色注册表"""
    
    def register_new_role(self, role_config: RoleConfig):
        """注册新的专家角色"""
        # 验证角色配置
        if self._validate_role_config(role_config):
            # 更新角色能力矩阵
            self.role_capabilities[role_config.name] = role_config.capabilities
            
            # 更新依赖关系
            self.dependencies[role_config.name] = role_config.dependencies
            
            # 注册角色提示词模板
            self.prompt_templates[role_config.name] = role_config.prompt_template
            
            logger.info(f"成功注册新角色: {role_config.name}")
```

### 11.2 角色配置示例
```python
# 新增营销分析师角色
marketing_analyst_config = RoleConfig(
    name="营销分析师",
    domain="marketing_analysis", 
    sub_domains=["market_research", "consumer_behavior", "campaign_analysis"],
    capabilities={
        "domains": ["marketing_analysis"],
        "sub_domains": ["market_research", "consumer_behavior", "campaign_analysis"],
        "complexity_preference": ["moderate", "complex"],
        "task_types": ["market_analysis", "campaign_evaluation", "consumer_research"],
        "outputs": ["marketing_reports", "campaign_insights", "market_recommendations"]
    },
    dependencies={
        "strong_dependencies": [],
        "weak_dependencies": ["调研分析师", "数据分析师"],
        "provides_for": ["技术写作专家"]
    }
)
```

## 12. 总结

智能决策层通过以下核心能力，为UAgent系统提供了强大的通用化智能支持：

1. **多领域任务分析**: 支持软件开发、数据分析、内容创作、信息处理等多个领域
2. **精准角色推荐**: 基于任务特点和角色能力矩阵，推荐最优的专家角色组合
3. **灵活依赖管理**: 支持跨领域角色协作和复杂任务的分解执行
4. **智能错误恢复**: 自动分类错误，生成恢复策略，支持自动和手动恢复
5. **动态角色扩展**: 支持新领域专家角色的动态注册和集成

该设计将UAgent从单一的编程助手升级为工程化的通用任务完成系统，能够通过专业角色协作，为用户提供高质量且精准的结果。系统具有良好的扩展性，可以根据需要添加更多领域的专家角色，实现真正的通用化智能协作。
